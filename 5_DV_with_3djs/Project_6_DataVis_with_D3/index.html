<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="d3.legend.js"></script>
    <script src="https://code.jquery.com/jquery-1.10.2.js"></script>
      <style>
        body {
          text-align: center;
        }

        .axis path {
          fill: none;
          stroke: lightgrey;
        }

        .axis font {
          font-family: arial;
          font-size: 0.9em;
        }

        .legend rect {
          fill: white;
          stroke: black;
          opacity: 0.8;
        }

        .description {
          font-family: arial;
          font-size: 1.2em;
        }

        h2 {
          font-family: arial;
          font-size: 3.4em;
        }

      </style>

    <script type="text/javascript">

    var format = d3.time.format("%Y")

    function draw(data) {

      var deleteTag = function(tagName) {
        var element = document.getElementsByTagName(tagName);
          for (index = element.length - 1; index >= 0; index--) {
              element[index].parentNode.removeChild(element[index]);
          }
      }

      deleteTag("svg");

      var width = 1600,
          height = 1000,
          margin = 120,
          vertical_correction = -84;

      var svg = d3.select(".chart").append("svg")
          .attr("width", width)
          .attr("height", height)
          .append("g")
          .attr("class", "chart");

      var select = undefined;

      if (document.getElementsByTagName("select").length == 0) {

        //creating the dropdown list
        select =  d3.select(".select")
            .append("select")
            .attr("class", "dropdown")
            .attr("id", "dropdown")
            .attr("onchange", "plot()");
      } else {
        select = d3.select("select");
      }

      //getting list of all values in the "Series" columns
      var all_categories = [];
      for (var i = 0; i < data.length; i++) {
        all_categories.push({long_name : data[i]["Series.Name"],
                             short_name : data[i]["Series.Code"]})
      };

      //getting rid of the repeating names in the all_categories list
      var categories = new Set();
      var filtered_categories = [];
      for (var i = 0; i < all_categories.length; i++) {
        if (!categories.has(all_categories[i].long_name)){
          categories.add(all_categories[i].long_name);
          filtered_categories.push(all_categories[i]);
        };
      };

      //adding filtered (unique) names of the series (indexes) to the dropdown
      select.selectAll("option")
          .data(filtered_categories)
          .enter()
          .append("option")
          .attr("value", function(d) {return d.short_name})
          .text(function(d) {return d.long_name});

      var selected_index = document.getElementById("dropdown").value;

      //drawing filled contour of USA
      var usa = $.getJSON("./usa_topo.json", function(topo_data) {

      var projection = d3.geo.albersUsa()
          .scale(600)
          .translate([width/3, height/3]);

      var path = d3.geo.path().projection(projection);

      var usa_map = svg.append("path")
                .datum(topojson.feature(topo_data, topo_data.objects.usa))
                .attr("d", path)
                .attr("fill", fill_by_index(data, selected_index, "USA"))
                .attr("fill-opacity", "0.6");
      });

      //drawing filler contour of Ukraine
      ukr = $.getJSON("ukr_topo.json", function(topo_data) {

      var projection = d3.geo.mercator()
          .scale(900)
          .center([34, 48])
          .translate([3*width/4.35, height/3]);

      var path = d3.geo.path().projection(projection);

      var ukr_map = svg.append("path")
                .datum(topojson.feature(topo_data, topo_data.objects.ukr))
                .attr("d", path)
                .attr("fill", fill_by_index(data, selected_index, "UKR"))
                .attr("fill-opacity", "0.6");;
       });

      //finding the min and max values (extend) of the future time axis
      var year_extent = d3.extent(data, function(d){
        return d["year"];
      });

      //translate found (year) extent to the pixel representation
      var year_scale = d3.time.scale()
          .range([width/4, 3*width/4])
          .domain(year_extent);

      //filter data for the chosen index and country (if given) on demand 
      var filter_data = function(data, index, country){

        var filteredData = [];
        for (var i = 0; i < data.length; i++) {
          if (data[i]["Series.Code"] === index) {
            if (country === undefined) {
              filteredData.push(data[i]);
            } else {
              if (data[i]["Country.Code"] === country) {
                filteredData.push(data[i]);
              }
            }
          }
        }
        return filteredData;
      };

      //finding the min and max values (extend) of the future values axis
      var index_extent = function(data, index) {
        return d3.extent(filter_data(data, index), function(d) {
              return d["value"];
            });
      };

      //translate found (index) extent to the pixel representation
      var index_scale = function(data, index) {
        return d3.scale.linear()
          .range([height, height/1.7])
          .domain(index_extent(data, index));
        };

      //finding the newest available data for both countries
      //returns year and values of the given index for USA and UKR (this order)
      var newest_data_same_year = function(data, index) {
        var filteredData = filter_data(data, index);
        var associativeArray = {};
        for (var i = 0; i < filteredData.length; i++) {
          var year = filteredData[i]["year"];
          if (associativeArray.hasOwnProperty(year)) {
            associativeArray[year].push(filteredData[i]);
          } else { 
              associativeArray[year] = [filteredData[i]];
          }
        }
        var sorted_years = get_keys(associativeArray).sort().reverse();
        for (var i = 0; i < sorted_years.length; i++) {
          var current_year = sorted_years[i];
          var all_for_current_year = associativeArray[current_year];
          if (!isNaN(all_for_current_year[0]["value"]) && 
              !isNaN(all_for_current_year[1]["value"])) {
            var ukr_value = 0;
            var usa_value = 0;
            if (all_for_current_year[0]["Country.Code"] === "UKR") {
              ukr_value = all_for_current_year[0]["value"]
              usa_value = all_for_current_year[1]["value"]
            } else {
              ukr_value = all_for_current_year[1]["value"]
              usa_value = all_for_current_year[0]["value"]
            }
            return [current_year, usa_value, ukr_value];
          }
        }
        return [current_year, 0, 0];
      };

      var get_keys = function(obj) {
          var keys = [];
          for(var key in obj)
          {
              if(obj.hasOwnProperty(key))
              {
                  keys.push(key);
              }
          }
          return keys;
      };

    var year_axis = d3.svg.axis()
                    .scale(year_scale)
                    .ticks(d3.time.years, 2);

    d3.select("svg")
        .append('g')
        .attr('class', 'x axis')
        .attr('transform', "translate(0," + 11*height/12 + ")")
        .call(year_axis);

    var index_axis = d3.svg.axis()
                     .scale(index_scale(data, selected_index))
                     .orient("left");

    d3.select("svg")
        .append('g')
        .attr('class', 'y axis')
        .attr('transform', "translate(" + (margin + 280) +  ", "
         + vertical_correction + ")")
        .call(index_axis);

    var current_index_scale = index_scale(data, selected_index);

    //creating line charts
    var lineGen = d3.svg.line()
        .defined(function(d) {
          return !isNaN(d.value);
        })
        .x(function(d) {
          return year_scale(d.year);
        })
        .y(function(d) {
          return current_index_scale(d.value);
        });

    d3.select("svg")
        .append("svg:path")
        .attr('d', lineGen(filter_data(data, selected_index, "UKR")))
        .attr('transform', "translate(0, " + vertical_correction + " )")
        .attr('stroke', 'grey')
        .attr('stroke-dasharray', '10,10')
        .attr('stroke-width', 2)
        .attr('fill', 'none')
        .attr('data-legend', function(d) {return 'Ukraine'});

    d3.select("svg")
        .append("svg:path")
        .attr('d', lineGen(filter_data(data, selected_index, "USA")))
        .attr('transform', "translate(0, " + vertical_correction + " )")
        .attr('stroke', 'black')
        .attr('stroke-width', 2)
        .attr('fill', 'none')
        .attr('data-legend', function(d) {return 'United States'});

    d3.select("svg")
      .selectAll("circle")
      .data(filter_data(data, selected_index, "USA").filter(function(d) { return !isNaN(d.value);}))
      .enter()
      .append("circle")
      .attr("cx", function(d) {
            return year_scale(d.year);
       })
       .attr("cy", function(d) {
            return current_index_scale(d.value);
       })
       .attr("r", 5)
       .attr('transform', "translate(0, " + vertical_correction + " )");

    d3.select("svg")
      .selectAll("rect")
      .data(filter_data(data, selected_index, "UKR").filter(function(d) { return !isNaN(d.value);}))
      .enter()
      .append("rect")
      .attr("x", function(d) {
            return year_scale(d.year) - 5;
       })
       .attr("y", function(d) {
            return current_index_scale(d.value) - 5;
       })
       .attr("width", 10)
       .attr("height", 10)
       .attr('transform', "translate(0, " + vertical_correction + " )")
       .attr('fill', '#C0C0C0');

    var newest_data = newest_data_same_year(data, selected_index);

    var newest_year = newest_data[0];
    var newest_data_usa = newest_data[1];
    var newest_data_ukr = newest_data[2];

    var newest_data_usa_offset = newest_data_usa.toString().length * 15;
    var newest_data_ukr_offset = newest_data_ukr.toString().length * 15;

    //display current values only if there is data for both 
    //countries for the same year
    if (newest_data_usa != 0 && newest_data_ukr != 0) {

      //adding newest available data year near the countries
      d3.select("svg")
          .append("svg:text")
          .text('data for ' + new Date(newest_year).getFullYear() + ' year')
          .attr('transform', 'translate(' + (3*width/4.35 + 140) +
            ',' + (height/3 + 100) + ')')
          .attr('font-size', 22)
          .attr('font-family', 'sans-serif');

      d3.select("svg")
          .append("svg:text")
          .text('the more—the better')
          .attr('transform', 'translate(' + (3*width/4.35 + 140) +
            ',' + (height/3 - 20) + ')')
          .attr('font-size', 22)
          .attr('font-family', 'sans-serif')
          .attr('fill', 'blue');

      d3.select("svg")
          .append("svg:text")
          .text('the less—the better')
          .attr('transform', 'translate(' + (3*width/4.35 + 140) +
            ',' + (height/3) + ')')
          .attr('font-size', 22)
          .attr('font-family', 'sans-serif')
          .attr('fill', 'red');

      d3.select("svg")
          .append("svg:text")
          .text('neutral')
          .attr('transform', 'translate(' + (3*width/4.35 + 140) +
            ',' + (height/3 + 20) + ')')
          .attr('font-size', 22)
          .attr('font-family', 'sans-serif')
          .attr('fill', 'gray');

      d3.select("svg")
          .append("svg:text")
          .text(newest_data_usa)
          .attr('transform', 'translate(' + (width/3 - newest_data_usa_offset) +
            ',' + (height/3) + ')')
          .attr('font-size', 50)
          .attr('font-family', 'sans-serif')
          .attr('fill', '#E5E4E2')
          .attr('font-weight', 'bold');

      d3.select("svg")
          .append("svg:text")
          .text(newest_data_ukr)
          .attr('transform', 'translate('
            + (3*width/4.35 - newest_data_ukr_offset) + ',' + (height/3) + ')')
          .attr('font-size', 50)
          .attr('font-family', 'sans-serif')
          .attr('fill', '#E5E4E2')
          .attr('font-weight', 'bold');

    } else {

      d3.select("svg")
          .append("svg:text")
          .text('no overlapping data available')
          .attr('transform', 'translate(' + (3*width/4.35 + 140) +
            ',' + (height/3 + 100) + ')')
          .attr('font-size', 22)
          .attr('font-family', 'sans-serif');
    }

    var fill_by_index = function(data, index, country) {
      var index_color = null;
      if (filter_data(data, selected_index, country)[0]["GBN"] == "bad") {
        index_color = "red";
      } else if (filter_data(data, selected_index, country)[0]["GBN"] == "good") {
        index_color = "blue";
      } else {
        index_color = "grey";
      }
      return index_color;
    };

    d3.select("svg")
        .append("g")
        .attr("class", "legend")
        .attr('transform','translate(' + (3*width/4.35 + 140) +
            ',' + (height/3 + 180) + ')')
        .style("font-size","20px")
        .call(d3.legend);


    };

    </script>

  </head>

<body>
  <h2> World Development Indicators: United Stated vs. Ukraine </h2>
  <div class="description"> kjefkwehfwefh </div>
  <div class="chart"> </div>
  <br/>
  <div class="select"> </div>

  <script type="text/javascript">

  function plot() {
      d3.csv("ua_usa_25_years_red.csv", function(d) {
        d["value"] = +d["value"];
        d["year"] = format.parse(d["year"]);
        return d;
    }, draw);
    };

  plot();

  </script>

</body>

</html>